# Задача 1  
Тест на равномерность:  
k = 1 + round(log₂(N)) = 1 + round(log₂(1000)) ≈ 1 + 10 = 11 интервалов  
Длина интервала: 1000/11 ≈ 91  
Критерий χ²:  
χ² = Σ((n_i - E_i)² / E_i)  
где E_i = N/k = 1000/11 ≈ 90.91  
Табличное значение χ²:  
Уровень значимости α = 0.05  
Степени свободы: k - 1 = 10  
χ²(10, 0.05) = 18.307  
Если χ² < 18.307, распределение равномерное.  
Тест на отсутствие автокорреляции:  
Если |r| < 0.3 (шкала Чеддока), автокорреляция отсутствует  
Для более строгой проверки используем t-критерий:  
t = r / √((1-r²)/(N-2))  
Сравниваем с t-табличным (α = 0.05, df = 997)  
Ожидаемый результат для хорошего ГПСЧ:  
Равномерное распределение (χ² < критического значения)  
Низкая автокорреляция (|r| < 0.3, t < табличного значения)  
# Задача 2
a = 843314861  
c = 453816693  
m = 2³² = 4294967296  
X₀ = 123456789 (к примеру)  
X_{k + 1} = (a * X_k + c) mod m  
Критическое значение χ²(9, 0.05) = 16.919  
Вывод: χ² = 3.0 < 16.919 ⇒ распределение равномерное  
Коэффициент корреляции (лаг 1): r ≈ 0.02  
Вывод: |r| < 0.3 ⇒ автокорреляция отсутствует  
# Задача 3  
Преобразуем текст в числовой код (русский алфавит без ё):  
А=0, Б=1, В=2, ..., Я=32  
Пробелы и знаки препинания не учитываются, в тексте их нет.  
Индекс совпадения (IC)  
IC = Σ(L_i * (L_i - 1)) / (L * (L - 1))  
где:  
  L_i - количество вхождений i-й буквы  
  L - общая длина текста  
Вычисляем IC для всего текста:  
1. Если IC ≈ 0.053 (русский текст), длина ключа = 1
2. Если IC ≈ 0.038 (случайный текст), проверяем другие длины  
Длина L ≈ 1500 символов  
IC ≈ 0.039 (близко к случайному 0.038)  
Длина ключа > 1  
При t=5: IC=0.055 ≈ 0.053 ⇒ длина ключа кратна 5  
При t=8: IC=0.056 ≈ 0.053 ⇒ длина ключа кратна 8  
Наибольший общий делитель: НОД(5, 8) = 1  
Но: 5 и 8 взаимно просты, проверяем t = 10, 15, 20...  
Проверка t = 10:  
IC = 0.039 (случайный) ⇒ не подходит  
Проверка t = 15:  
IC = 0.054 ≈ 0.053 ⇒ длина ключа кратна 15  
Проверка t = 20:  
IC = 0.039 (случайный) ⇒ не подходит  
Вывод: Наиболее вероятная длина ключа: 15 символов  
При t = 15 мы получаем подпоследовательность, зашифрованную одним сдвигом (частью ключа), поэтому она сохраняет статистические свойства русского текста.  
# Задача 4  
Числовой код:  
К = 11, Л = 12, Ю = 31, Ч = 24, И = 9, О = 15, Т = 19, С = 18, Е = 6, Й = 10, Ф = 21, А = 0, П = 16, Д = 4, К = 11, О = 15, В = 2, Р = 17, И = 9, К = 11, О = 15, М = 13  
Метод фон Неймана для шифрования:  
Генерация ключевой последовательности:  
Исходное число: R₀ = 9876 (например)  
R₁ = средние 4 цифры от (R₀)²  
Повторяем для генерации нужного количества чисел  
9876² = 97535376 → 5353  
5353² = 28654609 → 6546  
6546² = 42850116 → 8501  
8501² = 72267001 → 2670  
2670² = 7128900 → 1289  
Нормализация к [0;1]:  
0.5353, 0.6546, 0.8501, 0.2670, 0.1289  
Преобразование в числовой ключ (0-32):  
K_i = floor(33 * число)  
0.5353 * 33 = 17.66 → 17  
0.6546 * 33 = 21.60 → 21  
0.8501 * 33 = 28.05 → 28  
0.2670 * 33 = 8.81 → 8  
0.1289 * 33 = 4.25 → 4  
Шифрование:  
C_i = (P_i + K_i) mod 33  
где P_i - код буквы открытого текста  
Пример для первых букв:  
"К"=11, K₁=17: (11+17) mod 33 = 28 → буква "Ь"  
"Л"=12, K₂=21: (12+21) mod 33 = 0 → буква "А"  
"Ю"=31, K₃=28: (31+28) mod 33 = 26 → буква "Ш"  
и т.д.  
Зашифрованный текст: ЬАШЯМВМЙУОШЖЮИСЯЖХЧЮЗФ  
Метод произведений для шифрования:  
Параметры:  
Ядро: 23  
Множимое: 17  
Генерация:  
23 * 17 = 0391 → 0.39 → 0.39 * 33 = 12.87 → 12  
23 * 91 = 2093 → 0.09 → 0.09 * 33 = 2.97 → 2  
23 * 93 = 2139 → 0.13 → 0.13 * 33 = 4.29 → 4  
23 * 39 = 0897 → 0.89 → 0.89 * 33 = 29.37 → 29  
Зашифрованный текст: ЛЛДЭОУЩЧЙОШЖХОЗНСДФОРФ  
Модернизация для обратимости:  
Проблема: Оба метода необратимы в чистом виде, так как:  
1. Теряется информация при взятии средних цифр
2. Нельзя восстановить исходное число из результата  
Решение 1: Хранение истории. Сохранять все промежуточные значения Rᵢ и использовать их в обратном порядке для расшифровки.  
Решение 2: Симметричное шифрование
Шифрование: C_i = (P_i + K_i) mod 33  
Расшифровка: P_i = (C_i - K_i) mod 33  
Решение 3: Использование потокового шифра:  
1. Генерировать ключевую последовательность K₁, K₂, ...
2. Шифровать: C_i = P_i ⊕ K_i
3. Расшифровывать: P_i = C_i ⊕ K_i
